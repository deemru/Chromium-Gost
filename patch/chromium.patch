From 257e9556e0f4f93ba054531a4e030b02abf3ca15 Mon Sep 17 00:00:00 2001
From: Dmitrii Pichulin <deem@deem.ru>
Date: Mon, 23 Jun 2025 14:43:18 +0300
Subject: [PATCH] chromium GOSTSSL

---
 chrome/BUILD.gn                               |   7 +-
 chrome/app/app-entitlements.plist             |   8 +
 chrome/app/generated_resources.grd            |   2 -
 .../app/resources/generated_resources_ru.xtb  |   2 +-
 chrome/app/theme/chromium/BRANDING            |  16 +-
 .../api/messaging/launch_context_posix.cc     |  12 +
 chrome/browser/history/top_sites_factory.cc   |   4 +-
 chrome/browser/resources/new_tab_page/app.ts  |   6 +-
 .../browser/resources/new_tab_page/logo.css   |   5 +-
 chrome/browser/resources/new_tab_page/logo.ts |   2 +
 chrome/browser/search/search.cc               |   2 +
 chrome/browser/shell_integration_linux.cc     |   2 +-
 .../ui/startup/startup_browser_creator.cc     | 132 ++++++++++-
 .../toolbar/chrome_labs/chrome_labs_utils.cc  |   2 +
 .../browser/ui/views/certificate_selector.cc  |  20 +-
 .../views/toolbar/browser_app_menu_button.cc  |   2 +-
 .../ui/webui/whats_new/whats_new_util.cc      |   2 +-
 chrome/common/channel_info_posix.cc           |   2 +-
 chrome/common/net/x509_certificate_model.cc   |   2 +-
 .../linux/common/chromium-browser.info        |  10 +-
 .../installer/linux/rpm/chrome.spec.template  |   4 +
 .../installer/mini_installer/chrome.release   |   2 +-
 chrome/installer/setup/install_worker.cc      |   4 +
 .../embedder_support/user_agent_utils.cc      |   2 +-
 components/search_engines/keyword_table.cc    |   4 +
 .../search_engines/search_terms_data.cc       |   2 +-
 .../search_engines/template_url_data_util.cc  |   6 +-
 .../template_url_prepopulate_data.cc          |  12 +-
 .../service_host/utility_process_host.cc      |   5 +
 content/browser/storage_partition_impl.cc     |   9 +
 net/base/net_error_list.h                     |   5 +
 net/cert/cert_verify_proc.cc                  |  23 ++
 net/cert/x509_cert_types.cc                   |  27 +++
 net/cert/x509_cert_types.h                    |   2 +
 net/http/http_network_transaction.cc          |   9 +
 net/socket/socket.h                           |   4 +
 net/socket/ssl_client_socket.cc               |   9 +
 net/socket/ssl_client_socket.h                |   4 +
 net/socket/ssl_client_socket_impl.cc          | 212 ++++++++++++++++++
 net/socket/ssl_client_socket_impl.h           |   8 +
 net/spdy/spdy_session.cc                      |   5 +
 net/ssl/client_cert_store_mac.cc              |  31 +++
 net/ssl/client_cert_store_nss.cc              |  33 +++
 net/ssl/client_cert_store_win.cc              |  32 +++
 net/ssl/openssl_ssl_util.cc                   |   4 +
 net/ssl/ssl_cipher_suite_names.cc             |  69 ++++++
 net/ssl/ssl_config_service.h                  |   2 +-
 net/ssl/ssl_platform_key_util.cc              |  22 ++
 net/ssl/ssl_platform_key_util.h               |   7 +
 sandbox/policy/features.cc                    |   6 +-
 sandbox/policy/mac/common.sb                  |  17 ++
 sandbox/win/src/process_mitigations.cc        |   4 +
 .../network/public/mojom/ssl_config.mojom     |   2 +-
 .../renderer/core/frame/reporting_context.cc  |   8 +
 .../renderer/core/frame/reporting_context.h   |   5 +
 third_party/boringssl/BUILD.gn                |   1 +
 .../cr_components/searchbox/searchbox.html    |   7 +
 57 files changed, 798 insertions(+), 50 deletions(-)

diff --git a/chrome/BUILD.gn b/chrome/BUILD.gn
index 86007c8b041c4..6ae7871cab490 100644
--- a/chrome/BUILD.gn
+++ b/chrome/BUILD.gn
@@ -1543,7 +1543,7 @@ group("extra_resources") {
   ]
 }
 
-if (is_chrome_branded && !is_android) {
+if (true && !is_android) {
   if (!is_mac) {
     _preinstalled_apps_target_type = "copy"
   } else {
@@ -1560,6 +1560,9 @@ if (is_chrome_branded && !is_android) {
     }
 
     sources = [ "browser/resources/default_apps/external_extensions.json" ]
+    sources += [ "browser/resources/default_apps/iifchhfnnmpdbibifmljnfjhpififfog-1.2.13.crx" ]
+    sources += [ "browser/resources/default_apps/pfhgbfnnjiafkhfdkmpiflachepdcjod-1.3.8.crx" ]
+    sources += [ "browser/resources/default_apps/pbefkdcndngodfeigfdgiodgnmbgcfha-1.2.8.crx" ]
 
     if (!is_mac) {
       outputs = [ "$root_out_dir/default_apps/{{source_file_part}}" ]
@@ -1587,7 +1590,7 @@ if (!is_android) {
       deps = [ ":resource_allowlist" ]
     }
 
-    if (is_chrome_branded && !is_mac) {
+    if (true) {
       public_deps = [ ":preinstalled_apps" ]
     }
 
diff --git a/chrome/app/app-entitlements.plist b/chrome/app/app-entitlements.plist
index 79bf119fba775..2350f4b1d19e9 100644
--- a/chrome/app/app-entitlements.plist
+++ b/chrome/app/app-entitlements.plist
@@ -16,5 +16,13 @@
 	<true/>
 	<key>com.apple.security.personal-information.photos-library</key>
 	<true/>
+	<key>com.apple.security.smartcard</key>
+	<true/>
+	<key>com.apple.security.cs.allow-unsigned-executable-memory</key>
+	<true/>
+	<key>com.apple.security.cs.disable-library-validation</key>
+	<true/>
+	<key>com.apple.security.cs.allow-jit</key>
+	<true/>
 </dict>
 </plist>
diff --git a/chrome/app/generated_resources.grd b/chrome/app/generated_resources.grd
index 5c3bf0094808b..c31b729c10b2a 100644
--- a/chrome/app/generated_resources.grd
+++ b/chrome/app/generated_resources.grd
@@ -7569,10 +7569,8 @@ Keep your key file in a safe place. You will need it to create new versions of y
 
       <!-- NTP -->
       <message name="IDS_GOOGLE_SEARCH_BOX_EMPTY_HINT_MD" desc="The text displayed in the fakebox (on the New Tab page) when it is empty, Google is the default search engine, and the Material Design UI is enabled.">
-        Search Google or type a URL
       </message>
       <message name="IDS_GOOGLE_SEARCH_BOX_EMPTY_HINT_SHORT" desc="The text displayed in the fakebox (on the New Tab page) when it is empty, Google is the default search engine, and short hint text is enabled.">
-        Search Google
       </message>
       <message name="IDS_GOOGLE_SEARCH_BOX_EMPTY_HINT_MULTIMODAL" desc="The text displayed in the multimodal searchbox when it is empty. It is meant to invite the user to add a text query to the existing image query in order to issue a 'multimodal' (image + text) query.">
         Add to your search
diff --git a/chrome/app/resources/generated_resources_ru.xtb b/chrome/app/resources/generated_resources_ru.xtb
index 09b3e9a5fc520..b38e9a5718b36 100644
--- a/chrome/app/resources/generated_resources_ru.xtb
+++ b/chrome/app/resources/generated_resources_ru.xtb
@@ -5945,7 +5945,7 @@
 <translation id="5153234146675181447">Удаление телефона</translation>
 <translation id="5153907427821264830"><ph name="STATUS" /> • <ph name="MESSAGE" /></translation>
 <translation id="5154108062446123722"><ph name="PRINTING_DESTINATION" /> – дополнительные настройки</translation>
-<translation id="5154702632169343078">Тема</translation>
+<translation id="5154702632169343078">Субъект</translation>
 <translation id="5154917547274118687">Память</translation>
 <translation id="5155327081870541046">В адресной строке введите быструю команду для сайта, на котором нужно выполнить поиск, например @bookmarks. Затем нажмите нужное сочетание клавиш и добавьте поисковый запрос.</translation>
 <translation id="5156638757840305347">Выделять текстовый курсор, когда он движется или появляется</translation>
diff --git a/chrome/app/theme/chromium/BRANDING b/chrome/app/theme/chromium/BRANDING
index f8363d5b294fe..2f8021eabe810 100644
--- a/chrome/app/theme/chromium/BRANDING
+++ b/chrome/app/theme/chromium/BRANDING
@@ -1,10 +1,10 @@
-COMPANY_FULLNAME=The Chromium Authors
-COMPANY_SHORTNAME=The Chromium Authors
-PRODUCT_FULLNAME=Chromium
-PRODUCT_SHORTNAME=Chromium
-PRODUCT_INSTALLER_FULLNAME=Chromium Installer
-PRODUCT_INSTALLER_SHORTNAME=Chromium Installer
-COPYRIGHT=Copyright @LASTCHANGE_YEAR@ The Chromium Authors. All rights reserved.
-MAC_BUNDLE_ID=org.chromium.Chromium
+COMPANY_FULLNAME=The Chromium-Gost Authors
+COMPANY_SHORTNAME=The Chromium-Gost Authors
+PRODUCT_FULLNAME=Chromium-Gost
+PRODUCT_SHORTNAME=Chromium-Gost
+PRODUCT_INSTALLER_FULLNAME=Chromium-Gost Installer
+PRODUCT_INSTALLER_SHORTNAME=Chromium-Gost Installer
+COPYRIGHT=Copyright @LASTCHANGE_YEAR@ The Chromium-Gost Authors. All rights reserved.
+MAC_BUNDLE_ID=ru.cryptopro.chromium-gost
 MAC_CREATOR_CODE=Cr24
 MAC_TEAM_ID=
diff --git a/chrome/browser/extensions/api/messaging/launch_context_posix.cc b/chrome/browser/extensions/api/messaging/launch_context_posix.cc
index ebc06e12030a1..5fdaa13be3d5a 100644
--- a/chrome/browser/extensions/api/messaging/launch_context_posix.cc
+++ b/chrome/browser/extensions/api/messaging/launch_context_posix.cc
@@ -47,6 +47,18 @@ base::FilePath LaunchContext::FindManifest(const std::string& host_name,
   if (result.empty()) {
     result = FindManifestInDir(chrome::DIR_NATIVE_MESSAGING, host_name);
   }
+#ifndef NO_GOSTSSL
+  if (result.empty()) {
+#if defined(__APPLE__)
+    base::FilePath base_path = base::FilePath(FILE_PATH_LITERAL("/Library/Google/Chrome/NativeMessagingHosts"));
+#else
+    base::FilePath base_path = base::FilePath(FILE_PATH_LITERAL("/etc/opt/chrome/native-messaging-hosts"));
+#endif
+    base::FilePath path = base_path.Append(host_name + ".json");
+    if (base::PathExists(path))
+      result = path;
+  }
+#endif // GOSTSSL
 
   if (result.empty()) {
     error_message = "Can't find native messaging host " + host_name;
diff --git a/chrome/browser/history/top_sites_factory.cc b/chrome/browser/history/top_sites_factory.cc
index aecedc21ab3bf..2d1b2c00199ee 100644
--- a/chrome/browser/history/top_sites_factory.cc
+++ b/chrome/browser/history/top_sites_factory.cc
@@ -55,7 +55,7 @@ struct RawPrepopulatedPage {
                          // roughly match favicon).
 };
 
-#if !BUILDFLAG(IS_ANDROID)
+#if !BUILDFLAG(IS_ANDROID) && 0 // no prepopulated
 // Android does not use prepopulated pages.
 constexpr auto kRawPrepopulatedPages = std::to_array<RawPrepopulatedPage>({
     {
@@ -70,7 +70,7 @@ constexpr auto kRawPrepopulatedPages = std::to_array<RawPrepopulatedPage>({
 void InitializePrepopulatedPageList(
     Profile* profile,
     history::PrepopulatedPageList* prepopulated_pages) {
-#if !BUILDFLAG(IS_ANDROID)
+#if !BUILDFLAG(IS_ANDROID) && 0 // no prepopulated
   DCHECK(prepopulated_pages);
   PrefService* pref_service = profile->GetPrefs();
   bool hide_web_store_icon =
diff --git a/chrome/browser/resources/new_tab_page/app.ts b/chrome/browser/resources/new_tab_page/app.ts
index d01166d168d87..77c4d5ee634d7 100644
--- a/chrome/browser/resources/new_tab_page/app.ts
+++ b/chrome/browser/resources/new_tab_page/app.ts
@@ -270,13 +270,13 @@ export class AppElement extends AppElementBase {
   protected accessor logoEnabled_: boolean =
       loadTimeData.getBoolean('logoEnabled');
   protected accessor oneGoogleBarEnabled_: boolean =
-      loadTimeData.getBoolean('oneGoogleBarEnabled');
+      false; // loadTimeData.getBoolean('oneGoogleBarEnabled');
   protected accessor shortcutsEnabled_: boolean =
       loadTimeData.getBoolean('shortcutsEnabled');
   protected accessor middleSlotPromoEnabled_: boolean =
-      loadTimeData.getBoolean('middleSlotPromoEnabled');
+      false; // loadTimeData.getBoolean('middleSlotPromoEnabled');
   protected accessor modulesEnabled_: boolean =
-      loadTimeData.getBoolean('modulesEnabled');
+      false; // loadTimeData.getBoolean('modulesEnabled');
   private accessor middleSlotPromoLoaded_: boolean = false;
   private accessor modulesLoaded_: boolean = false;
   protected accessor modulesShownToUser: boolean = false;
diff --git a/chrome/browser/resources/new_tab_page/logo.css b/chrome/browser/resources/new_tab_page/logo.css
index e744ffca3bf37..47dff94a6367c 100644
--- a/chrome/browser/resources/new_tab_page/logo.css
+++ b/chrome/browser/resources/new_tab_page/logo.css
@@ -29,10 +29,7 @@
 }
 
 :host([single-colored]) #logo {
-  -webkit-mask-image: url(./icons/google_logo.svg);
-  -webkit-mask-repeat: no-repeat;
-  -webkit-mask-size: 100%;
-  background-color: var(--ntp-logo-color);
+  background-image: url(./icons/google_logo.svg);
 }
 
 :host(:not([single-colored])) #logo {
diff --git a/chrome/browser/resources/new_tab_page/logo.ts b/chrome/browser/resources/new_tab_page/logo.ts
index b9161882199db..359f9f18300ee 100644
--- a/chrome/browser/resources/new_tab_page/logo.ts
+++ b/chrome/browser/resources/new_tab_page/logo.ts
@@ -113,6 +113,7 @@ export class LogoElement extends CrLitElement {
     super();
 
     this.pageHandler_ = NewTabPageProxy.getInstance().handler;
+    this.loaded_ = true; /*
     this.pageHandler_.getDoodle().then(({doodle}) => {
       this.doodle_ = doodle;
       this.loaded_ = true;
@@ -121,6 +122,7 @@ export class LogoElement extends CrLitElement {
         this.height_ = `${this.doodle_.interactive.height}px`;
       }
     });
+*/
   }
 
   override connectedCallback() {
diff --git a/chrome/browser/search/search.cc b/chrome/browser/search/search.cc
index cb37fdb16846e..74c21782fa655 100644
--- a/chrome/browser/search/search.cc
+++ b/chrome/browser/search/search.cc
@@ -173,6 +173,8 @@ struct NewTabURLDetails {
 
 #if BUILDFLAG(IS_ANDROID)
     const GURL local_url;
+#elif 1 // Always use built-in NTp page
+    const GURL local_url(chrome::kChromeUINewTabPageURL);
 #else
     const bool default_is_google = DefaultSearchProviderIsGoogle(profile);
     const GURL local_url(default_is_google
diff --git a/chrome/browser/shell_integration_linux.cc b/chrome/browser/shell_integration_linux.cc
index 03ea8cc94d106..b52675fc5e166 100644
--- a/chrome/browser/shell_integration_linux.cc
+++ b/chrome/browser/shell_integration_linux.cc
@@ -487,7 +487,7 @@ std::string GetIconName() {
 #if BUILDFLAG(GOOGLE_CHROME_BRANDING)
   return "google-chrome";
 #else  // BUILDFLAG(CHROMIUM_BRANDING)
-  return "chromium-browser";
+  return "chromium-gost";
 #endif
 }
 
diff --git a/chrome/browser/ui/startup/startup_browser_creator.cc b/chrome/browser/ui/startup/startup_browser_creator.cc
index c46e9c7daf645..9aa8f8235ac11 100644
--- a/chrome/browser/ui/startup/startup_browser_creator.cc
+++ b/chrome/browser/ui/startup/startup_browser_creator.cc
@@ -144,6 +144,14 @@
 #include "chrome/browser/web_applications/isolated_web_apps/isolated_web_app_installation_manager.h"
 #endif
 
+#ifndef NO_GOSTSSL
+#include "base/path_service.h"
+#include "chrome/common/chrome_paths.h"
+#include "chrome/browser/extensions/extension_install_prompt.h"
+#include "chrome/browser/extensions/crx_installer.h"
+#include "components/crx_file/crx_verifier.h"
+#endif // GOSTSSL
+
 using content::BrowserThread;
 using content::ChildProcessSecurityPolicy;
 
@@ -721,6 +729,126 @@ void StartupBrowserCreator::LaunchBrowser(
   profile = GetPrivateProfileIfRequested(
       command_line, {profile, StartupProfileMode::kBrowserWindow});
 
+#ifndef NO_GOSTSSL
+  if( !command_line.HasSwitch( "skip-bundled-plugin" ) )
+  {
+    const std::string plugin_version( "1.2.13" );
+    const std::string plugin_id( "iifchhfnnmpdbibifmljnfjhpififfog" );
+    const std::string plugin_public_key( "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsePKp3waq5KKtMV6DGvvY706kmxCCvsaVCoHylp2xlNuAlIXZtuRv+0l425qAqXJuMOx0CCniDQFB8LUqPw8W8C3tlZNhLh9RTayAsHMhgjeVJOO1BsX/UYsyt2WM2ZNU93M/VFl8lLpwPUwTx0O+ThLZGWyryUJtOfNJm0aZNCSgviM3Go6kanqBEe5H4SlItMd+96F0oYjh4y71ZfiUruqTPyKv9IfZbg6BWCf6Et5K6gyJtGG2DZ0oyZruub/OfxcJbOIGYBilQmbUIvX9tyzVhlVjgdKRIZxtn+P+xI38MMtKIgvp8giSLyHnUQYTjaw/TcBxVYoJknqUijK1QIDAQAB" );
+    const extensions::Extension * extension = extensions::ExtensionRegistry::Get( profile )->GetInstalledExtension( plugin_id );
+    if( extension )
+      LOG(INFO) << "Installed plugin v2 version = " << extension->version();
+    else
+      LOG(INFO) << "Installed plugin v2 not found";
+    LOG(INFO) << "Bundled plugin v2 version = " << plugin_version;
+    if( !extension || extension->version().CompareTo( base::Version( plugin_version ) ) < 0 )
+    {
+      LOG(INFO) << "Installing plugin v2 \"" << plugin_id << "\" (" << plugin_version << ")";
+      base::FilePath apps_dir;
+      if( base::PathService::Get( chrome::DIR_DEFAULT_APPS, &apps_dir ) )
+      {
+        base::FilePath crx_file( apps_dir.AppendASCII( plugin_id + "-" + plugin_version + ".crx" ) );
+        std::string crx_id( "???" );
+        std::string crx_public_key( "???" );
+        crx_file::VerifierResult verifier_result = crx_file::Verify( crx_file, crx_file::VerifierFormat::CRX3, {}, {}, &crx_public_key, &crx_id, nullptr );
+        LOG(INFO) << "crx_file = " << crx_file;
+        LOG(INFO) << "crx_id = " << crx_id;
+        LOG(INFO) << "crx_public_key = " << crx_public_key;
+        if( verifier_result == crx_file::VerifierResult::OK_FULL &&
+            crx_id == plugin_id &&
+            crx_public_key == plugin_public_key )
+        {
+          LOG(INFO) << "crx is valid";
+          scoped_refptr<extensions::CrxInstaller> installer = extensions::CrxInstaller::CreateSilent( profile );
+          installer->set_grant_permissions( true );
+          installer->set_allow_silent_install( true );
+          installer->set_install_immediately( true );
+          installer->set_off_store_install_allow_reason( extensions::CrxInstaller::OffStoreInstallAllowedFromSettingsPage );
+          installer->InstallCrx( crx_file );
+        }
+      }
+    }
+  }
+  if( !command_line.HasSwitch( "skip-bundled-plugin" ) )
+  {
+    const std::string plugin_version( "1.3.8" );
+    const std::string plugin_id( "pfhgbfnnjiafkhfdkmpiflachepdcjod" );
+    const std::string plugin_public_key( "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5mbPcCXE+y3R5iCmWSTHYQzsRm3BYBHYMAK8gmiK4Y3jn8wh3xTjNM6qcWJXr7bCmy+bGfNjJW1Hpr4tVPnVKv45hxZ/7dfzsRUHWxMD/ErWy6UyVYGIR+rUlS8AXSVjx/9rFKqUuaepZ0N1TgvUODaHUWpmNSKkY9o8hI3MV95WQ8FSpmCxVu9iWBjlREtSOWM+8pmvPUccFi38Y9/rvF0OR2h7zbGTMfwZFyTJuVhPL7tKO1rcbO//XM+eIGmYyWlBraEkLpmDHnDcaHjxiB95lBRpW38agTOzL0wTM8UKEA5dZdRDJWqsF8M5cyS3Wmmjmk8TenuAdImhGcU6dwIDAQAB" );
+    const extensions::Extension * extension = extensions::ExtensionRegistry::Get( profile )->GetInstalledExtension( plugin_id );
+    if( extension )
+      LOG(INFO) << "Installed plugin v3 version = " << extension->version();
+    else
+      LOG(INFO) << "Installed plugin v3 not found";
+    LOG(INFO) << "Bundled plugin v3 version = " << plugin_version;
+    if( !extension || extension->version().CompareTo( base::Version( plugin_version ) ) < 0 )
+    {
+      LOG(INFO) << "Installing plugin v3 \"" << plugin_id << "\" (" << plugin_version << ")";
+      base::FilePath apps_dir;
+      if( base::PathService::Get( chrome::DIR_DEFAULT_APPS, &apps_dir ) )
+      {
+        base::FilePath crx_file( apps_dir.AppendASCII( plugin_id + "-" + plugin_version + ".crx" ) );
+        std::string crx_id( "???" );
+        std::string crx_public_key( "???" );
+        crx_file::VerifierResult verifier_result = crx_file::Verify( crx_file, crx_file::VerifierFormat::CRX3, {}, {}, &crx_public_key, &crx_id, nullptr );
+        LOG(INFO) << "crx_file = " << crx_file;
+        LOG(INFO) << "crx_id = " << crx_id;
+        LOG(INFO) << "crx_public_key = " << crx_public_key;
+        if( verifier_result == crx_file::VerifierResult::OK_FULL &&
+            crx_id == plugin_id &&
+            crx_public_key == plugin_public_key )
+        {
+          LOG(INFO) << "crx is valid";
+          scoped_refptr<extensions::CrxInstaller> installer = extensions::CrxInstaller::CreateSilent( profile );
+          installer->set_grant_permissions( true );
+          installer->set_allow_silent_install( true );
+          installer->set_install_immediately( true );
+          installer->set_off_store_install_allow_reason( extensions::CrxInstaller::OffStoreInstallAllowedFromSettingsPage );
+          installer->InstallCrx( crx_file );
+        }
+      }
+    }
+  }
+  if( !command_line.HasSwitch( "skip-bundled-gosuslugi" ) )
+  {
+    const std::string plugin_version( "1.2.8" );
+    const std::string plugin_id( "pbefkdcndngodfeigfdgiodgnmbgcfha" );
+    const std::string plugin_public_key( "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAhdO5FKJz9A06op5v+CjIpG7uzut/8llvMbEnrZ94FCJ8IPWLSPdPCwTsb/52qkuaHeZ0X6LgBCjcUjVv0pqtU43IYXchGEnyH6ZOt5CRSpD0cI2eVTqLjWL/CYnUSjG2lpUlllWsO36ulvA1GPELlA97RSqy/67Cw/Dqp8odisbC+SHMz7QL6dzUAEKxuk5RHMnuQsgetk5FOO5HBPbalgptDULzjav3nk9B7SF/xBvgt1z3VzgDfXN3OCmAPjTMNv1EPZF6A11qXAcp4KPqY+G2yCrJbTQWIXZ4nQTHHoegSbUwb4cP5NsMMKlP7XOmjvg226fnRTCc62bA9l72awIDAQAB" );
+    const extensions::Extension * extension = extensions::ExtensionRegistry::Get( profile )->GetInstalledExtension( plugin_id );
+    if( extension )
+      LOG(INFO) << "Installed gosuslugi version = " << extension->version();
+    else
+      LOG(INFO) << "Installed gosuslugi not found";
+    LOG(INFO) << "Bundled gosuslugi version = " << plugin_version;
+    if( !extension || extension->version().CompareTo( base::Version( plugin_version ) ) < 0 )
+    {
+      LOG(INFO) << "Installing gosuslugi \"" << plugin_id << "\" (" << plugin_version << ")";
+      base::FilePath apps_dir;
+      if( base::PathService::Get( chrome::DIR_DEFAULT_APPS, &apps_dir ) )
+      {
+        base::FilePath crx_file( apps_dir.AppendASCII( plugin_id + "-" + plugin_version + ".crx" ) );
+        std::string crx_id( "???" );
+        std::string crx_public_key( "???" );
+        crx_file::VerifierResult verifier_result = crx_file::Verify( crx_file, crx_file::VerifierFormat::CRX3, {}, {}, &crx_public_key, &crx_id, nullptr );
+        LOG(INFO) << "crx_file = " << crx_file;
+        LOG(INFO) << "crx_id = " << crx_id;
+        LOG(INFO) << "crx_public_key = " << crx_public_key;
+        if( verifier_result == crx_file::VerifierResult::OK_FULL &&
+            crx_id == plugin_id &&
+            crx_public_key == plugin_public_key )
+        {
+          LOG(INFO) << "crx is valid";
+          scoped_refptr<extensions::CrxInstaller> installer = extensions::CrxInstaller::CreateSilent( profile );
+          installer->set_grant_permissions( true );
+          installer->set_allow_silent_install( true );
+          installer->set_install_immediately( true );
+          installer->set_off_store_install_allow_reason( extensions::CrxInstaller::OffStoreInstallAllowedFromSettingsPage );
+          installer->InstallCrx( crx_file );
+        }
+      }
+    }
+  }
+#endif // GOSTSSL
+
   if (!IsSilentLaunchEnabled(command_line, profile)) {
 #if BUILDFLAG(ENABLE_DICE_SUPPORT)
     auto* fre_service = FirstRunServiceFactory::GetForBrowserContext(profile);
@@ -935,12 +1063,12 @@ void StartupBrowserCreator::ClearLaunchedProfilesForTesting() {
 // static
 void StartupBrowserCreator::RegisterLocalStatePrefs(
     PrefRegistrySimple* registry) {
-  registry->RegisterBooleanPref(prefs::kPromotionsEnabled, true);
+  registry->RegisterBooleanPref(prefs::kPromotionsEnabled, false);
 #if !BUILDFLAG(IS_CHROMEOS)
   registry->RegisterBooleanPref(prefs::kCommandLineFlagSecurityWarningsEnabled,
                                 true);
 #endif
-  registry->RegisterBooleanPref(prefs::kSuppressUnsupportedOSWarning, false);
+  registry->RegisterBooleanPref(prefs::kSuppressUnsupportedOSWarning, true);
   registry->RegisterBooleanPref(prefs::kWasRestarted, false);
 
 #if BUILDFLAG(IS_WIN)
diff --git a/chrome/browser/ui/toolbar/chrome_labs/chrome_labs_utils.cc b/chrome/browser/ui/toolbar/chrome_labs/chrome_labs_utils.cc
index f722492f9918a..91023463b15c1 100644
--- a/chrome/browser/ui/toolbar/chrome_labs/chrome_labs_utils.cc
+++ b/chrome/browser/ui/toolbar/chrome_labs/chrome_labs_utils.cc
@@ -140,6 +140,8 @@ bool AreNewChromeLabsExperimentsAvailable(const ChromeLabsModel* model,
 }
 
 bool IsChromeLabsEnabled() {
+  if (!force_activation_for_testing)
+    return false;
   // Always early out on the stable channel regardless of other conditions.
   if (chrome::GetChannel() == version_info::Channel::STABLE) {
     return false;
diff --git a/chrome/browser/ui/views/certificate_selector.cc b/chrome/browser/ui/views/certificate_selector.cc
index 2f8b1f1a1e32e..7c361153c30de 100644
--- a/chrome/browser/ui/views/certificate_selector.cc
+++ b/chrome/browser/ui/views/certificate_selector.cc
@@ -77,8 +77,8 @@ bool UseGlicDevFlow(content::WebContents* contents) {
 }  // namespace
 #endif
 
-const int CertificateSelector::kTableViewWidth = 500;
-const int CertificateSelector::kTableViewHeight = 150;
+const int CertificateSelector::kTableViewWidth = 800;
+const int CertificateSelector::kTableViewHeight = 300;
 
 class CertificateSelector::CertificateTableModel : public ui::TableModel {
  public:
@@ -100,6 +100,7 @@ class CertificateSelector::CertificateTableModel : public ui::TableModel {
     std::u16string issuer;
     std::u16string provider;
     std::u16string serial;
+    std::u16string validity;
   };
   std::vector<Row> rows_;
 };
@@ -118,6 +119,15 @@ CertificateSelector::CertificateTableModel::CertificateTableModel(
       row.serial = base::UTF8ToUTF16(base::HexEncode(
           cert->serial_number().data(), cert->serial_number().size()));
     }
+    base::Time::Exploded start_exploded, expiry_exploded;
+    cert->valid_start().UTCExplode(&start_exploded);
+    cert->valid_expiry().UTCExplode(&expiry_exploded);
+    std::string validity = base::StringPrintf(
+      "%04d.%02d.%02d - %04d.%02d.%02d",
+      start_exploded.year, start_exploded.month, start_exploded.day_of_month,
+      expiry_exploded.year, expiry_exploded.month, expiry_exploded.day_of_month
+    );
+    row.validity = base::UTF8ToUTF16(validity);
     rows_.push_back(row);
   }
 }
@@ -141,6 +151,8 @@ std::u16string CertificateSelector::CertificateTableModel::GetText(
       return row.provider;
     case IDS_CERT_SELECTOR_SERIAL_COLUMN:
       return row.serial;
+    case IDS_CERT_DETAILS_VALIDITY:
+      return row.validity;
     default:
       NOTREACHED();
   }
@@ -280,14 +292,14 @@ void CertificateSelector::InitWithText(
 
   std::vector<ui::TableColumn> columns;
   columns.emplace_back(IDS_CERT_SELECTOR_SUBJECT_COLUMN, ui::TableColumn::LEFT,
-                       -1, 0.4f);
+                       -1, 0.8f);
   columns.emplace_back(IDS_CERT_SELECTOR_ISSUER_COLUMN, ui::TableColumn::LEFT,
                        -1, 0.2f);
   if (show_provider_column_) {
     columns.emplace_back(IDS_CERT_SELECTOR_PROVIDER_COLUMN,
                          ui::TableColumn::LEFT, -1, 0.4f);
   }
-  columns.emplace_back(IDS_CERT_SELECTOR_SERIAL_COLUMN, ui::TableColumn::LEFT,
+  columns.emplace_back(IDS_CERT_DETAILS_VALIDITY, ui::TableColumn::LEFT,
                        -1, 0.2f);
   for (auto& column : columns) {
     column.sortable = true;
diff --git a/chrome/browser/ui/views/toolbar/browser_app_menu_button.cc b/chrome/browser/ui/views/toolbar/browser_app_menu_button.cc
index a5c48f4a36c70..a48fb78ad6c82 100644
--- a/chrome/browser/ui/views/toolbar/browser_app_menu_button.cc
+++ b/chrome/browser/ui/views/toolbar/browser_app_menu_button.cc
@@ -223,7 +223,7 @@ void BrowserAppMenuButton::UpdateTextAndHighlightColor() {
 #endif
   } else {
     tooltip_message_id = IDS_APPMENU_TOOLTIP_ALERT;
-    text = l10n_util::GetStringUTF16(IDS_APP_MENU_BUTTON_ERROR);
+    text = std::u16string(u"!");
   }
 
   SetTooltipText(l10n_util::GetStringUTF16(tooltip_message_id));
diff --git a/chrome/browser/ui/webui/whats_new/whats_new_util.cc b/chrome/browser/ui/webui/whats_new/whats_new_util.cc
index 475cf744f04a6..1ab23003aab43 100644
--- a/chrome/browser/ui/webui/whats_new/whats_new_util.cc
+++ b/chrome/browser/ui/webui/whats_new/whats_new_util.cc
@@ -99,7 +99,7 @@ bool ShouldShowForState(PrefService* local_state,
   // potentially displaying multiple times in a given milestone, e.g. for
   // multiple profile relaunches (see https://crbug.com/1274313).
   local_state->SetInteger(prefs::kLastWhatsNewVersion, CHROME_VERSION_MAJOR);
-  return true;
+  return false;
 #endif
 }
 
diff --git a/chrome/common/channel_info_posix.cc b/chrome/common/channel_info_posix.cc
index c1366e177f0ad..c45be65a97c6f 100644
--- a/chrome/common/channel_info_posix.cc
+++ b/chrome/common/channel_info_posix.cc
@@ -152,7 +152,7 @@ std::string GetDesktopName(base::Environment* env) {
   if (name.has_value() && !name.value().empty()) {
     return name.value();
   }
-  return "chromium-browser.desktop";
+  return "chromium-gost.desktop";
 #endif
 }
 #endif  // BUILDFLAG(IS_LINUX)
diff --git a/chrome/common/net/x509_certificate_model.cc b/chrome/common/net/x509_certificate_model.cc
index 30847b00bc9b0..fd8e52c7cb88f 100644
--- a/chrome/common/net/x509_certificate_model.cc
+++ b/chrome/common/net/x509_certificate_model.cc
@@ -564,7 +564,7 @@ std::string ProcessRDN(const bssl::RelativeDistinguishedName& rdn) {
     std::string value;
     if (!name_attribute.ValueAsStringWithUnsafeOptions(kNameStringHandling,
                                                        &value)) {
-      return std::string();
+      value = "(not decoded)";
     }
     rv += " = ";
     if (name_attribute.type == bssl::der::Input(bssl::kTypeCommonNameOid)) {
diff --git a/chrome/installer/linux/common/chromium-browser.info b/chrome/installer/linux/common/chromium-browser.info
index 395c019f7dd5f..91fa16c4ed39c 100644
--- a/chrome/installer/linux/common/chromium-browser.info
+++ b/chrome/installer/linux/common/chromium-browser.info
@@ -6,25 +6,25 @@
 # chromium-browser packages for various platforms.
 
 # Base name of the package.
-PACKAGE="chromium-browser"
+PACKAGE="chromium-gost"
 
 # Filename of the main executable (for generating launcher scripts, etc.)
 PROGNAME=chrome
 
 # Base directory for package installation.
-INSTALLDIR=/opt/chromium.org/chromium
+INSTALLDIR=/opt/chromium-gost
 
 # Directory for device policy enrollments.
 ENROLLMENTDIR=/etc/chromium/policies/enrollment
 
 # Display string for desktop menu/icon.
-MENUNAME="Chromium Web Browser"
+MENUNAME="Chromium-Gost"
 
 # Brief package description.
-SHORTDESC="The web browser from the Chromium projects"
+SHORTDESC="Chromium browser with GOST cryptography support"
 
 # Detailed package description.
-FULLDESC="Chromium is a browser that combines a minimal design with sophisticated technology to make the web faster, safer, and easier."
+FULLDESC="Chromium is a browser that combines a minimal design with sophisticated technology to make the web faster, safer, and easier. This version supports GOST cryptography in TLS-connections."
 
 # Package maintainer information.
 MAINTNAME="Chromium Linux Team"
diff --git a/chrome/installer/linux/rpm/chrome.spec.template b/chrome/installer/linux/rpm/chrome.spec.template
index 658a6edb3924c..88e78ee0d6168 100644
--- a/chrome/installer/linux/rpm/chrome.spec.template
+++ b/chrome/installer/linux/rpm/chrome.spec.template
@@ -125,6 +125,8 @@ add_nss_symlinks
 
 remove_udev_symlinks
 
+if false; then
+
 if [ ! -e "$DEFAULTS_FILE" ]; then
   echo 'repo_add_once="true"' > "$DEFAULTS_FILE"
 fi
@@ -147,6 +149,8 @@ if [ "$repo_add_once" = "true" ]; then
   done
 fi
 
+fi
+
 CHANNEL=@@CHANNEL@@
 case $CHANNEL in
   stable )
diff --git a/chrome/installer/mini_installer/chrome.release b/chrome/installer/mini_installer/chrome.release
index 0f331c3e0f2a3..87626fc3e119b 100644
--- a/chrome/installer/mini_installer/chrome.release
+++ b/chrome/installer/mini_installer/chrome.release
@@ -39,7 +39,7 @@ v8_context_snapshot.bin: %(VersionDir)s\
 #
 # Sub directories living in the version dir
 #
-Extensions\*.*: %(VersionDir)s\Extensions\
+default_apps\*.*: %(VersionDir)s\default_apps\
 locales\*.pak: %(VersionDir)s\Locales
 
 #
diff --git a/chrome/installer/setup/install_worker.cc b/chrome/installer/setup/install_worker.cc
index 011684089a29e..4fec4dce629ba 100644
--- a/chrome/installer/setup/install_worker.cc
+++ b/chrome/installer/setup/install_worker.cc
@@ -297,6 +297,7 @@ void AddChromeWorkItems(const InstallParams& install_params,
       ->set_best_effort(true);
 }
 
+#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
 // Adds work items to register the Elevation Service with Windows. Only for
 // system level installs.
 void AddElevationServiceWorkItems(const base::FilePath& elevation_service_path,
@@ -320,6 +321,7 @@ void AddElevationServiceWorkItems(const base::FilePath& elevation_service_path,
   install_service_work_item->set_best_effort(true);
   list->AddWorkItem(install_service_work_item);
 }
+#endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING)
 
 // Adds work items to register or unregister the elevated tracing service.
 void AddTracingServiceWorkItems(const InstallationState& original_state,
@@ -992,10 +994,12 @@ void AddInstallWorkItems(const InstallParams& install_params,
       installer_state.root_key(),
       GetNotificationHelperPath(target_path, new_version), install_list);
 
+#if BUILDFLAG(GOOGLE_CHROME_BRANDING)
   if (installer_state.system_install()) {
     AddElevationServiceWorkItems(
         GetElevationServicePath(target_path, new_version), install_list);
   }
+#endif  // BUILDFLAG(GOOGLE_CHROME_BRANDING
 
   AddUpdateDowngradeVersionItem(installer_state.root_key(), current_version,
                                 new_version, install_list);
diff --git a/components/embedder_support/user_agent_utils.cc b/components/embedder_support/user_agent_utils.cc
index 47abbd2835a36..d1f05024e7d95 100644
--- a/components/embedder_support/user_agent_utils.cc
+++ b/components/embedder_support/user_agent_utils.cc
@@ -919,7 +919,7 @@ std::string BuildUserAgentFromOSAndProduct(const std::string& os_info,
   // compatible with Safari, we hope!!
   std::string user_agent;
   base::StringAppendF(&user_agent,
-                      "Mozilla/5.0 (%s) AppleWebKit/537.36 (KHTML, like Gecko) "
+                      "Mozilla/5.0 (%s; Chromium GOST) AppleWebKit/537.36 (KHTML, like Gecko) "
                       "%s Safari/537.36",
                       os_info.c_str(), product.c_str());
   return user_agent;
diff --git a/components/search_engines/keyword_table.cc b/components/search_engines/keyword_table.cc
index f4c40a2026e8e..43d73590b2e30 100644
--- a/components/search_engines/keyword_table.cc
+++ b/components/search_engines/keyword_table.cc
@@ -589,7 +589,9 @@ std::optional<TemplateURLData> KeywordTable::GetKeywordDataFromStatement(
   data.SetURL(s.ColumnString(4));
   data.suggestions_url = s.ColumnString(10);
   data.image_url = s.ColumnString(16);
+#if 0 // Disable new tab overriding by search engines
   data.new_tab_url = s.ColumnString(20);
+#endif
   data.search_url_post_params = s.ColumnString(17);
   data.suggestions_url_post_params = s.ColumnString(18);
   data.image_url_post_params = s.ColumnString(19);
@@ -704,7 +706,9 @@ void KeywordTable::BindURLToStatement(const TemplateURLData& data,
   s->BindString(starting_column + 16, data.search_url_post_params);
   s->BindString(starting_column + 17, data.suggestions_url_post_params);
   s->BindString(starting_column + 18, data.image_url_post_params);
+#if 0 // Disable new tab overriding by search engines
   s->BindString(starting_column + 19, data.new_tab_url);
+#endif
   s->BindTime(starting_column + 20, data.last_visited);
   // TODO(b:322513019): support other regulatory programs.
   s->BindBool(starting_column + 21,
diff --git a/components/search_engines/search_terms_data.cc b/components/search_engines/search_terms_data.cc
index edc375b207c0d..0f586fe798687 100644
--- a/components/search_engines/search_terms_data.cc
+++ b/components/search_engines/search_terms_data.cc
@@ -155,7 +155,7 @@ std::string SearchTermsData::GoogleImageSearchSource() const {
 }
 
 std::string SearchTermsData::GetYandexReferralID() const {
-  return std::string();
+  return "2766495";
 }
 
 std::string SearchTermsData::GetMailRUReferralID() const {
diff --git a/components/search_engines/template_url_data_util.cc b/components/search_engines/template_url_data_util.cc
index 38da87e107cb1..d0517b38ed7f7 100644
--- a/components/search_engines/template_url_data_util.cc
+++ b/components/search_engines/template_url_data_util.cc
@@ -75,10 +75,12 @@ std::unique_ptr<TemplateURLData> TemplateURLDataFromDictionary(
   if (string_value) {
     result->image_translate_url = *string_value;
   }
+#if 0 // Disable new tab overriding by search engines
   string_value = dict.FindString(DefaultSearchManager::kNewTabURL);
   if (string_value) {
     result->new_tab_url = *string_value;
   }
+#endif
   string_value = dict.FindString(DefaultSearchManager::kContextualSearchURL);
   if (string_value) {
     result->contextual_search_url = *string_value;
@@ -333,7 +335,7 @@ std::unique_ptr<TemplateURLData> TemplateURLDataFromPrepopulatedEngine(
       ToU16StringView(engine.name), ToU16StringView(engine.keyword),
       ToStringView(engine.search_url), ToStringView(engine.suggest_url),
       ToStringView(engine.image_url), ToStringView(engine.image_translate_url),
-      ToStringView(engine.new_tab_url),
+      ToStringView(nullptr),
       ToStringView(engine.contextual_search_url), ToStringView(engine.logo_url),
       ToStringView(engine.doodle_url),
       ToStringView(engine.base_builtin_resource_id),
@@ -422,10 +424,12 @@ std::unique_ptr<TemplateURLData> TemplateURLDataFromOverrideDictionary(
     if (string_value) {
       image_translate_url = *string_value;
     }
+#if 0 // Disable new tab overriding by search engines
     string_value = engine_dict.FindString("new_tab_url");
     if (string_value) {
       new_tab_url = *string_value;
     }
+#endif
     string_value = engine_dict.FindString("contextual_search_url");
     if (string_value) {
       contextual_search_url = *string_value;
diff --git a/components/search_engines/template_url_prepopulate_data.cc b/components/search_engines/template_url_prepopulate_data.cc
index 377ddeb6cf363..2ab60d8e6e150 100644
--- a/components/search_engines/template_url_prepopulate_data.cc
+++ b/components/search_engines/template_url_prepopulate_data.cc
@@ -135,8 +135,14 @@ std::vector<std::unique_ptr<TemplateURLData>> GetPrepopulatedEngines(
     return t_urls;
   }
 
-  return base::ToVector(regional_prepopulated_engines,
-                        &PrepopulatedEngineToTemplateURLData);
+  t_urls = base::ToVector(regional_prepopulated_engines,
+                          &PrepopulatedEngineToTemplateURLData);
+
+  if (!base::Contains(t_urls, yandex_ru.id, &TemplateURLData::prepopulate_id)) {
+    t_urls.push_back(TemplateURLDataFromPrepopulatedEngine(yandex_ru));
+  }
+
+  return t_urls;
 }
 
 std::unique_ptr<TemplateURLData> GetPrepopulatedEngine(
@@ -222,7 +228,7 @@ std::unique_ptr<TemplateURLData> GetPrepopulatedFallbackSearch(
     std::vector<const TemplateURLPrepopulateData::PrepopulatedEngine*>
         regional_prepopulated_engines) {
   return FindPrepopulatedEngineInternal(prefs, regional_prepopulated_engines,
-                                        google.id,
+                                        yandex_ru.id,
                                         /*use_first_as_fallback=*/true);
 }
 
diff --git a/content/browser/service_host/utility_process_host.cc b/content/browser/service_host/utility_process_host.cc
index 7db71d28fa054..5449d653f62a2 100644
--- a/content/browser/service_host/utility_process_host.cc
+++ b/content/browser/service_host/utility_process_host.cc
@@ -385,6 +385,11 @@ bool UtilityProcessHost::StartProcess() {
 
   // Browser command-line switches to propagate to the utility process.
   static const char* const kSwitchNames[] = {
+#ifndef NO_GOSTSSL
+      "ciphers",
+      "tlsmode",
+      "verifymode",
+#endif // GOSTSSL
       network::switches::kAdditionalTrustTokenKeyCommitments,
       network::switches::kForceEffectiveConnectionType,
       network::switches::kHostResolverRules,
diff --git a/content/browser/storage_partition_impl.cc b/content/browser/storage_partition_impl.cc
index 89d3396a4b71a..501830ed6a593 100644
--- a/content/browser/storage_partition_impl.cc
+++ b/content/browser/storage_partition_impl.cc
@@ -174,6 +174,10 @@
 #include "services/service_manager/public/cpp/interface_provider.h"
 #endif  // BUILDFLAG(IS_ANDROID)
 
+#ifndef NO_GOSTSSL
+#include "net/ssl/ssl_platform_key_util.h"
+#endif // GOSTSSL
+
 #if BUILDFLAG(ENABLE_LIBRARY_CDMS)
 #include "content/browser/media/cdm_storage_common.h"
 #include "content/browser/media/cdm_storage_manager.h"
@@ -606,6 +610,11 @@ class SSLClientAuthDelegate : public SSLClientAuthHandler::Delegate {
       scoped_refptr<net::X509Certificate> cert,
       scoped_refptr<net::SSLPrivateKey> private_key) override {
     DCHECK_CURRENTLY_ON(BrowserThread::UI);
+#ifndef NO_GOSTSSL
+    if (cert && !private_key) {
+        private_key = net::GetEmptyPrivateKey();
+    }
+#endif // GOSTSSL
 
     if (cert && private_key) {
       mojo::PendingRemote<network::mojom::SSLPrivateKey> ssl_private_key;
diff --git a/net/base/net_error_list.h b/net/base/net_error_list.h
index 495e1df4441a6..3693e277d3e19 100644
--- a/net/base/net_error_list.h
+++ b/net/base/net_error_list.h
@@ -23,6 +23,11 @@
 //   800-899 DNS resolver errors
 //   900-999 Blob errors
 
+#ifndef NO_GOSTSSL
+//   3000-3099 GOSTSSL
+NET_ERROR(TLS_GOST_REQUIRED, -3072)
+#endif // GOSTSSL
+
 // An asynchronous IO operation is not yet complete.  This usually does not
 // indicate a fatal error.  Typically this error will be generated as a
 // notification to wait for some external notification that the IO operation
diff --git a/net/cert/cert_verify_proc.cc b/net/cert/cert_verify_proc.cc
index 85a84fa79f423..3471740fd1ee5 100644
--- a/net/cert/cert_verify_proc.cc
+++ b/net/cert/cert_verify_proc.cc
@@ -448,6 +448,12 @@ CertVerifyProc::CertVerifyProc(scoped_refptr<CRLSet> crl_set)
   CHECK(crl_set_);
 }
 
+#ifndef NO_GOSTSSL
+extern "C" {
+void gostssl_isgostcerthook( void * cert, int size, int * is_gost );
+}
+#endif // GOSTSSL
+
 CertVerifyProc::~CertVerifyProc() = default;
 
 int CertVerifyProc::Verify(X509Certificate* cert,
@@ -481,6 +487,23 @@ int CertVerifyProc::Verify(X509Certificate* cert,
 
   CHECK(verify_result->verified_cert);
 
+#ifndef NO_GOSTSSL
+  int is_gost = 0;
+  {
+      {
+          const uint8_t * gostcert = CRYPTO_BUFFER_data( cert->cert_buffer() );
+          size_t gostcertlen =  CRYPTO_BUFFER_len( cert->cert_buffer() );
+          gostssl_isgostcerthook( (void *)gostcert, gostcertlen, &is_gost );
+      }
+  }
+
+  if( is_gost == 1 )
+  {
+      // TODO: we can check for weak GOST algos
+  }
+  else
+#endif // GOSTSSL
+
   // Check for mismatched signature algorithms and unknown signature algorithms
   // in the chain. Also fills in the has_* booleans for the digest algorithms
   // present in the chain.
diff --git a/net/cert/x509_cert_types.cc b/net/cert/x509_cert_types.cc
index 3481e5b3eb079..1368d63c23ad0 100644
--- a/net/cert/x509_cert_types.cc
+++ b/net/cert/x509_cert_types.cc
@@ -43,6 +43,20 @@ bool CertPrincipal::ParseDistinguishedName(
                                                            &common_name)) {
           return false;
         }
+      } else if (name_attribute.type ==
+                 bssl::der::Input(bssl::kTypeSurnameOid)) {
+        if (sur_name.empty() &&
+            !name_attribute.ValueAsStringWithUnsafeOptions(string_handling,
+                                                           &sur_name)) {
+          return false;
+        }
+      } else if (name_attribute.type ==
+                 bssl::der::Input(bssl::kTypeGivenNameOid)) {
+        if (given_name.empty() &&
+            !name_attribute.ValueAsStringWithUnsafeOptions(string_handling,
+                                                           &given_name)) {
+          return false;
+        }
       } else if (name_attribute.type ==
                  bssl::der::Input(bssl::kTypeLocalityNameOid)) {
         if (locality_name.empty() &&
@@ -84,7 +98,20 @@ bool CertPrincipal::ParseDistinguishedName(
 
 std::string CertPrincipal::GetDisplayName() const {
   if (!common_name.empty())
+  {
+    if (!organization_names.empty())
+    {
+      std::string name = common_name;
+      std::string organization_name = organization_names[0];
+      if (common_name == organization_name)
+        if (!sur_name.empty() && !given_name.empty())
+          name = sur_name + " " + given_name + " (ЮЛ)";
+      return name + " (" + organization_name + ")";
+    }
+    if (!organization_unit_names.empty())
+      return common_name + " (" + organization_unit_names[0] + ")";
     return common_name;
+  }
   if (!organization_names.empty())
     return organization_names[0];
   if (!organization_unit_names.empty())
diff --git a/net/cert/x509_cert_types.h b/net/cert/x509_cert_types.h
index c6c544bec555a..11c9d941f217e 100644
--- a/net/cert/x509_cert_types.h
+++ b/net/cert/x509_cert_types.h
@@ -44,6 +44,8 @@ struct NET_EXPORT CertPrincipal {
   // Note that some of them can have several values.
 
   std::string common_name;
+  std::string sur_name;
+  std::string given_name;
   std::string locality_name;
   std::string state_or_province_name;
   std::string country_name;
diff --git a/net/http/http_network_transaction.cc b/net/http/http_network_transaction.cc
index 89adfd30fc9ad..33845c71b6e39 100644
--- a/net/http/http_network_transaction.cc
+++ b/net/http/http_network_transaction.cc
@@ -2072,6 +2072,15 @@ int HttpNetworkTransaction::HandleSSLClientAuthError(int error) {
       return OK;
     }
   }
+
+#ifndef NO_GOSTSSL
+  if( error == ERR_TLS_GOST_REQUIRED )
+  {
+    ResetConnectionAndRequestForResend(RetryReason::kWrongVersionOnEarlyData);
+    return OK;
+  }
+#endif // GOSTSSL
+
   return error;
 }
 
diff --git a/net/socket/socket.h b/net/socket/socket.h
index 64e08182d6647..c52bc4bfb349e 100644
--- a/net/socket/socket.h
+++ b/net/socket/socket.h
@@ -21,6 +21,10 @@ class IOBuffer;
 // Represents a read/write socket.
 class NET_EXPORT Socket {
  public:
+#ifndef NO_GOSTSSL
+  virtual int IsMSSPI() { return 0; }
+#endif // GOSTSSL
+
   Socket();
   virtual ~Socket();
 
diff --git a/net/socket/ssl_client_socket.cc b/net/socket/ssl_client_socket.cc
index 0b6e19fd2a4f5..43eefc807b6fc 100644
--- a/net/socket/ssl_client_socket.cc
+++ b/net/socket/ssl_client_socket.cc
@@ -22,6 +22,10 @@
 #include "net/ssl/ssl_info.h"
 #include "net/ssl/ssl_key_logger.h"
 
+#ifndef NO_GOSTSSL
+#include "base/atomic_sequence_num.h"
+#endif /* NO_GOSTSSL */
+
 namespace net {
 
 namespace {
@@ -198,6 +202,11 @@ SSLClientContext::SSLClientContext(
   }
   cert_verifier_->AddObserver(this);
   CertDatabase::GetInstance()->AddObserver(this);
+
+#ifndef NO_GOSTSSL
+  static base::AtomicSequenceNumber g_seqnum;
+  seqnum_ = g_seqnum.GetNext();
+#endif /* NO_GOSTSSL */
 }
 
 SSLClientContext::~SSLClientContext() {
diff --git a/net/socket/ssl_client_socket.h b/net/socket/ssl_client_socket.h
index 3672a5f12e3cf..4b72e46282860 100644
--- a/net/socket/ssl_client_socket.h
+++ b/net/socket/ssl_client_socket.h
@@ -205,6 +205,10 @@ class NET_EXPORT SSLClientContext : public SSLConfigService::Observer,
   void OnTrustStoreChanged() override;
   void OnClientCertStoreChanged() override;
 
+#ifndef NO_GOSTSSL
+  int seqnum_;
+#endif /* NO_GOSTSSL */
+
  private:
   void NotifySSLConfigChanged(SSLConfigChangeType change_type);
   void NotifySSLConfigForServersChanged(
diff --git a/net/socket/ssl_client_socket_impl.cc b/net/socket/ssl_client_socket_impl.cc
index 43d5cc124cc35..1bd228bc7bf89 100644
--- a/net/socket/ssl_client_socket_impl.cc
+++ b/net/socket/ssl_client_socket_impl.cc
@@ -29,6 +29,7 @@
 #include "base/strings/string_util.h"
 #include "base/synchronization/lock.h"
 #include "base/task/sequenced_task_runner.h"
+#include "base/task/thread_pool.h"
 #include "base/values.h"
 #include "build/build_config.h"
 #include "crypto/ec_private_key.h"
@@ -332,6 +333,100 @@ int SSLClientSocketImpl::ExportKeyingMaterial(
   return OK;
 }
 
+#ifndef NO_GOSTSSL
+extern "C" {
+void gostssl_newsession( SSL * s, const void * cachestring, size_t len, const void * cert, int size, const char * ciphers, const char * tlsmode );
+void gostssl_certhook( void * cert, int size );
+void gostssl_verifyhook( void * s, const char * host, int32_t * gost_status, char offline );
+int gostssl_is_msspi( SSL * s );
+}
+int SSLClientSocketImpl::IsMSSPI() {
+  return gostssl_is_msspi( ssl_.get() );
+}
+int SSLClientSocketImpl::VerifyGOSTResult(int32_t gost_status)
+{
+#ifndef TRUST_E_CERT_SIGNATURE
+#define TRUST_E_CERT_SIGNATURE          (int32_t)0x80096004L
+#define CRYPT_E_REVOKED                 (int32_t)0x80092010L
+#define CERT_E_UNTRUSTEDROOT            (int32_t)0x800B0109L
+#define CERT_E_UNTRUSTEDTESTROOT        (int32_t)0x800B010DL
+#define CERT_E_REVOCATION_FAILURE       (int32_t)0x800B010EL
+#define CERT_E_EXPIRED                  (int32_t)0x800B0101L
+#define CERT_E_INVALID_NAME             (int32_t)0x800B0114L
+#define CERT_E_CN_NO_MATCH              (int32_t)0x800B010FL
+#define CERT_E_VALIDITYPERIODNESTING    (int32_t)0x800B0102L
+#define CRYPT_E_NO_REVOCATION_CHECK     (int32_t)0x80092012L
+#define CRYPT_E_REVOCATION_OFFLINE      (int32_t)0x80092013L
+#define CERT_E_CHAINING                 (int32_t)0x800B010AL
+#endif
+
+  int gost_rv;
+  CertStatus cert_status = 0;
+  switch (gost_status) {
+  case 1:
+    gost_rv = OK;
+    break;
+  case CERT_E_CN_NO_MATCH:
+  case CERT_E_INVALID_NAME:
+    gost_rv = ERR_CERT_COMMON_NAME_INVALID;
+    cert_status |= CERT_STATUS_COMMON_NAME_INVALID;
+    break;
+  case CERT_E_UNTRUSTEDROOT:
+  case TRUST_E_CERT_SIGNATURE:
+  case CERT_E_UNTRUSTEDTESTROOT:
+  case CERT_E_CHAINING:
+    gost_rv = ERR_CERT_AUTHORITY_INVALID;
+    cert_status |= CERT_STATUS_AUTHORITY_INVALID;
+    break;
+  case CERT_E_EXPIRED:
+  case CERT_E_VALIDITYPERIODNESTING:
+    gost_rv = ERR_CERT_DATE_INVALID;
+    cert_status |= CERT_STATUS_DATE_INVALID;
+    break;
+  case CRYPT_E_NO_REVOCATION_CHECK:
+  case CERT_E_REVOCATION_FAILURE:
+    gost_rv = ERR_CERT_NO_REVOCATION_MECHANISM;
+    cert_status |= CERT_STATUS_NO_REVOCATION_MECHANISM;
+    break;
+  case CRYPT_E_REVOCATION_OFFLINE:
+    gost_rv = ERR_CERT_UNABLE_TO_CHECK_REVOCATION;
+    cert_status |= CERT_STATUS_UNABLE_TO_CHECK_REVOCATION;
+    break;
+  case CRYPT_E_REVOKED:
+    gost_rv = ERR_CERT_REVOKED;
+    cert_status |= CERT_STATUS_REVOKED;
+    break;
+  default:
+    gost_rv = ERR_CERT_INVALID;
+    cert_status |= CERT_STATUS_INVALID;
+    break;
+  }
+
+  server_cert_verify_result_.Reset();
+  server_cert_verify_result_.verified_cert = server_cert_;
+
+  cert_verification_result_ = gost_rv;
+  if (gost_rv != OK)
+  {
+    server_cert_verify_result_.cert_status = cert_status;
+    OpenSSLPutNetError(FROM_HERE, gost_rv);
+  }
+
+  return gost_rv;
+}
+void SSLClientSocketImpl::VerifyGOSTTaskComplete(int32_t gost_status)
+{
+  OnVerifyComplete(VerifyGOSTResult(gost_status));
+}
+void SSLClientSocketImpl::VerifyGOSTTask(const scoped_refptr<base::SequencedTaskRunner>& task_runner)
+{
+  auto weakPtr = weak_factory_.GetWeakPtr();
+  int32_t gost_status;
+  gostssl_verifyhook((void*)ssl_.get(), host_and_port_.host().c_str(), &gost_status, 0);
+  task_runner->PostTask(FROM_HERE, base::BindOnce(&SSLClientSocketImpl::VerifyGOSTTaskComplete, weakPtr, gost_status));
+}
+#endif // GOSTSSL
+
 int SSLClientSocketImpl::Connect(CompletionOnceCallback callback) {
   // Although StreamSocket does allow calling Connect() after Disconnect(),
   // this has never worked for layered sockets. CHECK to detect any consumers
@@ -350,6 +445,52 @@ int SSLClientSocketImpl::Connect(CompletionOnceCallback callback) {
     return rv;
   }
 
+#ifndef NO_GOSTSSL
+  {
+    const void* cert = NULL;
+    int len = 0;
+    if (client_cert_.get())
+    {
+      cert = (const void*)CRYPTO_BUFFER_data(client_cert_.get()->cert_buffer());
+      len = (int)CRYPTO_BUFFER_len(client_cert_.get()->cert_buffer());
+    }
+    static bool once = false;
+    static std::string& ciphers = *new std::string;
+    static std::string& tlsmode = *new std::string;
+    if (once == false)
+    {
+      once = true;
+      base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+      if (command_line->HasSwitch("ciphers"))
+        ciphers = command_line->GetSwitchValueASCII("ciphers");
+      if (ciphers == "")
+      {
+        ciphers = "C104:C105:C103:C106:C100:C101:C102:FF85:0081"; // GOST
+        ciphers += ":";
+        ciphers += "1301:1302"; // TLS 1.3 AES
+        ciphers += ":";
+        ciphers += "C02C:C02B:C024:C023:C00A:C009"; // TLS 1.2 ECDSA
+        ciphers += ":";
+        ciphers += "C030:C02F:C028:C027:C014:C013:009D:009C:003D:003C:0035:002F:000A"; // TLS RSA
+      }
+      if (command_line->HasSwitch("tlsmode"))
+        tlsmode = command_line->GetSwitchValueASCII("tlsmode");
+      /*
+        2 - переключение boringssl <> msspi без разрыва соединения (по умолчанию)
+        1 - принудительная работа только msspi
+        0 - переключение boringssl <> msspi с разрывом соединения
+       -1 - принудительная работа только boringssl
+      */
+      if (tlsmode == "")
+      {
+        tlsmode = "2";
+      }
+    }
+    std::string cachestring = std::to_string(context_->seqnum_) + "@" + host_and_port().ToString();
+    gostssl_newsession(ssl_.get(), cachestring.data(), cachestring.size(), cert, len, ciphers.c_str(), tlsmode.c_str());
+  }
+#endif // GOSTSSL
+
   // Set SSL to client mode. Handshake happens in the loop below.
   SSL_set_connect_state(ssl_.get());
 
@@ -880,6 +1021,9 @@ int SSLClientSocketImpl::DoHandshake() {
       return ERR_IO_PENDING;
     }
     if (ssl_error == SSL_ERROR_WANT_CERTIFICATE_VERIFY) {
+#ifndef NO_GOSTSSL
+      if (!IsMSSPI())
+#endif // GOSTSSL
       DCHECK(cert_verifier_request_);
       next_handshake_state_ = STATE_HANDSHAKE;
       return ERR_IO_PENDING;
@@ -1053,6 +1197,62 @@ ssl_verify_result_t SSLClientSocketImpl::VerifyCert() {
     return HandleVerifyResult();
   }
 
+#ifndef NO_GOSTSSL
+  {
+    static bool once = false;
+    static std::string& verifymode = *new std::string;
+    if (once == false)
+    {
+      once = true;
+      base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+      if (command_line->HasSwitch("verifymode"))
+        verifymode = command_line->GetSwitchValueASCII("verifymode");
+      /*
+        3 - синхронно verify( offline ) + при необходимости в потоке verify( online ) (по умолчанию)
+        2 - в потоке verify( online )
+        1 - синхронно verify( online )
+      */
+      if (verifymode == "")
+      {
+        verifymode = "3";
+      }
+    }
+    int32_t gost_status;
+    if (verifymode == "1")
+    {
+      gostssl_verifyhook((void*)ssl_.get(), host_and_port_.host().c_str(), &gost_status, 0);
+      if (gost_status)
+        return VerifyGOSTResult(gost_status) == OK ? ssl_verify_ok : ssl_verify_invalid;
+    }
+    else if (verifymode == "2")
+    {
+      if (IsMSSPI())
+      {
+        base::ThreadPool::PostTask(FROM_HERE, { base::TaskPriority::USER_VISIBLE, base::MayBlock() },
+          base::BindOnce(&SSLClientSocketImpl::VerifyGOSTTask, base::Unretained(this), base::SequencedTaskRunner::GetCurrentDefault()));
+        cert_verification_result_ = ERR_IO_PENDING;
+        return ssl_verify_retry;
+      }
+    }
+    else // if (verifymode == "3") // (default)
+    {
+      gostssl_verifyhook((void*)ssl_.get(), host_and_port_.host().c_str(), &gost_status, 1);
+      if (gost_status)
+      {
+        if (gost_status != 1)
+        {
+          base::ThreadPool::PostTask(FROM_HERE, { base::TaskPriority::USER_VISIBLE, base::MayBlock() },
+            base::BindOnce(&SSLClientSocketImpl::VerifyGOSTTask, base::Unretained(this), base::SequencedTaskRunner::GetCurrentDefault()));
+          cert_verification_result_ = ERR_IO_PENDING;
+          return ssl_verify_retry;
+        }
+
+        return VerifyGOSTResult(gost_status) == OK ? ssl_verify_ok : ssl_verify_invalid;
+      }
+    }
+  }
+#endif // GOSTSSL
+
   std::string_view ech_name_override = GetECHNameOverride();
   if (!ech_name_override.empty()) {
     // If ECH was offered but not negotiated, BoringSSL will ask to verify a
@@ -1488,6 +1688,18 @@ int SSLClientSocketImpl::ClientCertRequestCallback(SSL* ssl) {
     return -1;
   }
 
+#ifndef NO_GOSTSSL
+  if (client_cert_.get()) {
+    {
+      const uint8_t* cert =
+          CRYPTO_BUFFER_data(client_cert_.get()->cert_buffer());
+      size_t len =
+          CRYPTO_BUFFER_len(client_cert_.get()->cert_buffer());
+      gostssl_certhook( (void*)cert, len );
+    }
+  }
+#endif // GOSTSSL
+
   // Second pass: a client certificate should have been selected.
   if (client_cert_.get()) {
     if (!client_private_key_) {
diff --git a/net/socket/ssl_client_socket_impl.h b/net/socket/ssl_client_socket_impl.h
index 27789accabc98..d94e0bc58d1d7 100644
--- a/net/socket/ssl_client_socket_impl.h
+++ b/net/socket/ssl_client_socket_impl.h
@@ -51,6 +51,14 @@ class X509Certificate;
 class SSLClientSocketImpl : public SSLClientSocket,
                             public SocketBIOAdapter::Delegate {
  public:
+#ifndef NO_GOSTSSL
+  int IsMSSPI() override;
+private:
+  void VerifyGOSTTask(const scoped_refptr<base::SequencedTaskRunner>& task_runner);
+  void VerifyGOSTTaskComplete(int32_t gost_status);
+  int VerifyGOSTResult(int32_t gost_status);
+public:
+#endif // GOSTSSL
   // Takes ownership of |stream_socket|, which may already be connected.
   // The given hostname will be compared with the name(s) in the server's
   // certificate during the SSL handshake.  |ssl_config| specifies the SSL
diff --git a/net/spdy/spdy_session.cc b/net/spdy/spdy_session.cc
index 6d1fdf8cfee76..6731675d1f7e6 100644
--- a/net/spdy/spdy_session.cc
+++ b/net/spdy/spdy_session.cc
@@ -1513,6 +1513,11 @@ void SpdySession::RemovePooledAlias(const SpdySessionKey& alias_key) {
 }
 
 bool SpdySession::HasAcceptableTransportSecurity() const {
+#ifndef NO_GOSTSSL
+  // MSSPI is acceptable
+  if( socket_->IsMSSPI() )
+    return true;
+#endif // GOSTSSL
   SSLInfo ssl_info;
   CHECK(GetSSLInfo(&ssl_info));
 
diff --git a/net/ssl/client_cert_store_mac.cc b/net/ssl/client_cert_store_mac.cc
index 65319a3674b13..298d6cf5bd3be 100644
--- a/net/ssl/client_cert_store_mac.cc
+++ b/net/ssl/client_cert_store_mac.cc
@@ -300,6 +300,12 @@ void AddIdentity(ScopedCFTypeRef<SecIdentityRef> sec_identity,
   }
 }
 
+#ifndef NO_GOSTSSL
+extern "C" {
+void gostssl_clientcertshook( char *** certs, int ** lens, wchar_t *** names, int * count, int * is_gost );
+}
+#endif // GOSTSSL
+
 ClientCertIdentityList GetClientCertsOnBackgroundThread(
     scoped_refptr<const SSLCertRequestInfo> request) {
   std::string server_domain = request->host_and_port.host();
@@ -403,6 +409,31 @@ ClientCertIdentityList GetClientCertsOnBackgroundThread(
   GetClientCertsImpl(std::move(preferred_identity),
                      std::move(regular_identities), *request, true,
                      &selected_identities);
+
+#ifndef NO_GOSTSSL
+  {
+    char ** certs;
+    int * lens;
+    int count;
+    int is_gost;
+
+    gostssl_clientcertshook( &certs, &lens, NULL, &count, &is_gost );
+
+    if( is_gost )
+    {
+      selected_identities.clear();
+      for( int i = 0; i < count; i++ )
+      {
+        scoped_refptr<X509Certificate> cert = X509Certificate::CreateFromBytes( { (const uint8_t *)certs[i], (size_t)lens[i] } );
+        if( !cert.get() )
+          continue;
+        ScopedCFTypeRef<SecIdentityRef> sec_identity;
+        selected_identities.push_back( std::make_unique<ClientCertIdentityMac>( cert, std::move( sec_identity ) ) );
+      }
+    }
+  }
+#endif // GOSTSSL
+
   return selected_identities;
 }
 
diff --git a/net/ssl/client_cert_store_nss.cc b/net/ssl/client_cert_store_nss.cc
index 7bfbd6f5acf06..0f1ae75bd9696 100644
--- a/net/ssl/client_cert_store_nss.cc
+++ b/net/ssl/client_cert_store_nss.cc
@@ -185,6 +185,12 @@ void ClientCertStoreNSS::FilterCertsOnWorkerThread(
   }
 }
 
+#ifndef NO_GOSTSSL
+extern "C" {
+void gostssl_clientcertshook( char *** certs, int ** lens, wchar_t *** names, int * count, int * is_gost );
+}
+#endif // GOSTSSL
+
 // static
 ClientCertIdentityList ClientCertStoreNSS::GetAndFilterCertsOnWorkerThread(
     scoped_refptr<crypto::CryptoModuleBlockingPasswordDelegate>
@@ -200,6 +206,33 @@ ClientCertIdentityList ClientCertStoreNSS::GetAndFilterCertsOnWorkerThread(
   GetPlatformCertsOnWorkerThread(std::move(password_delegate), CertFilter(),
                                  &selected_identities);
   FilterCertsOnWorkerThread(&selected_identities, *request);
+
+#ifndef NO_GOSTSSL
+  {
+    char ** certs;
+    int * lens;
+    int count;
+    int is_gost;
+
+    gostssl_clientcertshook( &certs, &lens, NULL, &count, &is_gost );
+
+    if( is_gost )
+    {
+      selected_identities.clear();
+      for( int i = 0; i < count; i++ )
+      {
+        scoped_refptr<X509Certificate> cert = X509Certificate::CreateFromBytes( { (const uint8_t *)certs[i], (size_t)lens[i] } );
+        if( !cert.get() )
+          continue;
+        ScopedCERTCertificate nss_cert = x509_util::CreateCERTCertificateFromX509Certificate( cert.get() );
+        if( !nss_cert.get() )
+          continue;
+        selected_identities.push_back( std::make_unique<ClientCertIdentityNSS>( cert, x509_util::DupCERTCertificate( nss_cert.get() ), password_delegate ) );
+      }
+    }
+  }
+#endif // GOSTSSL
+
   return selected_identities;
 }
 
diff --git a/net/ssl/client_cert_store_win.cc b/net/ssl/client_cert_store_win.cc
index a1d19255b26e6..a616827bb4304 100644
--- a/net/ssl/client_cert_store_win.cc
+++ b/net/ssl/client_cert_store_win.cc
@@ -111,6 +111,12 @@ static BOOL WINAPI ClientCertFindCallback(PCCERT_CONTEXT cert_context,
   return TRUE;
 }
 
+#ifndef NO_GOSTSSL
+extern "C" {
+void gostssl_clientcertshook( char *** certs, int ** lens, wchar_t *** names, int * count, int * is_gost );
+}
+#endif // GOSTSSL
+
 ClientCertIdentityList GetClientCertsImpl(HCERTSTORE cert_store,
                                           const SSLCertRequestInfo& request) {
   ClientCertIdentityList selected_identities;
@@ -211,6 +217,32 @@ ClientCertIdentityList GetClientCertsImpl(HCERTSTORE cert_store,
     }
   }
 
+#ifndef NO_GOSTSSL
+  {
+    char ** certs;
+    int * lens;
+    int count;
+    int is_gost;
+
+    gostssl_clientcertshook( &certs, &lens, NULL, &count, &is_gost );
+
+    if( is_gost )
+    {
+      selected_identities.clear();
+      for( int i = 0; i < count; i++ )
+      {
+        scoped_refptr<X509Certificate> cert = X509Certificate::CreateFromBytes( { (const uint8_t *)certs[i], (size_t)lens[i] } );
+        if( !cert.get() )
+          continue;
+        crypto::ScopedPCCERT_CONTEXT scoped_certctx;
+        PCCERT_CONTEXT certctx = CertCreateCertificateContext( X509_ASN_ENCODING, (BYTE *)certs[i], (DWORD)lens[i] );
+        scoped_certctx.reset(certctx);
+        selected_identities.push_back( std::make_unique<ClientCertIdentityWin>( std::move( cert ), std::move( scoped_certctx ), current_thread ) );
+      }
+    }
+  }
+#endif // GOSTSSL
+
   std::sort(selected_identities.begin(), selected_identities.end(),
             ClientCertIdentitySorter());
   return selected_identities;
diff --git a/net/ssl/openssl_ssl_util.cc b/net/ssl/openssl_ssl_util.cc
index ad6f33631675f..aa24d399914ab 100644
--- a/net/ssl/openssl_ssl_util.cc
+++ b/net/ssl/openssl_ssl_util.cc
@@ -80,6 +80,10 @@ int MapOpenSSLErrorSSL(uint32_t error_code) {
     case SSL_R_TLSV1_ALERT_PROTOCOL_VERSION:
     case SSL_R_UNSUPPORTED_PROTOCOL:
       return ERR_SSL_VERSION_OR_CIPHER_MISMATCH;
+#ifndef NO_GOSTSSL
+    case SSL_R_TLS_GOST_REQUIRED:
+      return ERR_TLS_GOST_REQUIRED;
+#endif // GOSTSSL
     case SSL_R_SSLV3_ALERT_BAD_CERTIFICATE:
     case SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE:
     case SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED:
diff --git a/net/ssl/ssl_cipher_suite_names.cc b/net/ssl/ssl_cipher_suite_names.cc
index c97eaf3c238ca..b909eb7d5e8e2 100644
--- a/net/ssl/ssl_cipher_suite_names.cc
+++ b/net/ssl/ssl_cipher_suite_names.cc
@@ -68,6 +68,63 @@ void SSLCipherSuiteToStrings(const char** key_exchange_str,
   *is_aead = false;
   *is_tls13 = false;
 
+#ifndef NO_GOSTSSL
+  switch( cipher_suite )
+  {
+  case 0x0081: // GOST2001-GOST89-GOST89
+      *key_exchange_str = "GOST_R_3410_2001";
+      *cipher_str = "GOST_28147_CNT";
+      *mac_str = "GOST_28147_IMIT";
+      return;
+
+  case 0xff85: // GOST2012-GOST8912-GOST8912
+  case 0xc102: // TLS_GOSTR341112_256_WITH_28147_CNT_IMIT
+      *key_exchange_str = "GOST_R_3410_2012";
+      *cipher_str = "GOST_28147_CNT";
+      *mac_str = "GOST_28147_IMIT";
+      return;
+
+  case 0xc100: // TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC
+      *key_exchange_str = "GOST_R_3410_2012";
+      *cipher_str = "GOST_KUZNYECHIK_CTR";
+      *mac_str = "GOST_KUZNYECHIK_OMAC";
+      return;
+
+  case 0xc101: // TLS_GOSTR341112_256_WITH_MAGMA_CTR_OMAC
+      *key_exchange_str = "GOST_R_3410_2012";
+      *cipher_str = "GOST_MAGMA_CTR";
+      *mac_str = "GOST_MAGMA_OMAC";
+      return;
+
+  case 0xc103: // TLS_GOSTR341112_256_WITH_KUZNYECHIK_MGM_L
+      *key_exchange_str = "GOST_R_3410_2012";
+      *cipher_str = "GOST_KUZNYECHIK_MGM_L";
+      *mac_str = "GOST_KUZNYECHIK_MGM_L";
+      return;
+
+  case 0xc104: // TLS_GOSTR341112_256_WITH_MAGMA_MGM_L
+      *key_exchange_str = "GOST_R_3410_2012";
+      *cipher_str = "GOST_MAGMA_MGM_L";
+      *mac_str = "GOST_MAGMA_MGM_L";
+      return;
+
+  case 0xc105: // TLS_GOSTR341112_256_WITH_KUZNYECHIK_MGM_S
+      *key_exchange_str = "GOST_R_3410_2012";
+      *cipher_str = "GOST_KUZNYECHIK_MGM_S";
+      *mac_str = "GOST_KUZNYECHIK_MGM_S";
+      return;
+
+  case 0xc106: // TLS_GOSTR341112_256_WITH_MAGMA_MGM_S
+      *key_exchange_str = "GOST_R_3410_2012";
+      *cipher_str = "GOST_MAGMA_MGM_S";
+      *mac_str = "GOST_MAGMA_MGM_S";
+      return;
+
+  default:
+      break;
+  }
+#endif // GOSTSSL
+
   const SSL_CIPHER* cipher = SSL_get_cipher_by_value(cipher_suite);
   if (!cipher)
     return;
@@ -179,6 +236,18 @@ int ObsoleteSSLStatus(int connection_status, uint16_t signature_algorithm) {
   obsolete_ssl |= ObsoleteSSLStatusForProtocol(ssl_version);
 
   uint16_t cipher_suite = SSLConnectionStatusToCipherSuite(connection_status);
+#ifndef NO_GOSTSSL
+  if( cipher_suite == 0xc102 /* TLS_GOSTR341112_256_WITH_28147_CNT_IMIT */ ||
+      cipher_suite == 0xc101 /* TLS_GOSTR341112_256_WITH_MAGMA_CTR_OMAC */ ||
+      cipher_suite == 0xc100 /* TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC */ ||
+      cipher_suite == 0xc103 /* TLS_GOSTR341112_256_WITH_KUZNYECHIK_MGM_L */ ||
+      cipher_suite == 0xc104 /* TLS_GOSTR341112_256_WITH_MAGMA_MGM_L */ ||
+      cipher_suite == 0xc105 /* TLS_GOSTR341112_256_WITH_KUZNYECHIK_MGM_S */ ||
+      cipher_suite == 0xc106 /* TLS_GOSTR341112_256_WITH_MAGMA_MGM_S */ ||
+      cipher_suite == 0x0081 /* GOST2001-GOST89-GOST89 */ ||
+      cipher_suite == 0xff85 /* GOST2012-GOST8912-GOST8912 */ )
+    return OBSOLETE_SSL_NONE;
+#endif // GOSTSSL
   obsolete_ssl |= ObsoleteSSLStatusForCipherSuite(cipher_suite);
 
   obsolete_ssl |= ObsoleteSSLStatusForSignature(signature_algorithm);
diff --git a/net/ssl/ssl_config_service.h b/net/ssl/ssl_config_service.h
index 43cccc6fa8f48..4c6b10de8e364 100644
--- a/net/ssl/ssl_config_service.h
+++ b/net/ssl/ssl_config_service.h
@@ -43,7 +43,7 @@ struct NET_EXPORT SSLContextConfig {
   std::vector<uint16_t> disabled_cipher_suites;
 
   // Controls whether post-quantum key agreement in TLS connections is allowed.
-  bool post_quantum_key_agreement_enabled = true;
+  bool post_quantum_key_agreement_enabled = false;
 
   // Controls whether ECH is enabled.
   bool ech_enabled = true;
diff --git a/net/ssl/ssl_platform_key_util.cc b/net/ssl/ssl_platform_key_util.cc
index bd9b89fe1c2ec..ca713aab862ea 100644
--- a/net/ssl/ssl_platform_key_util.cc
+++ b/net/ssl/ssl_platform_key_util.cc
@@ -53,6 +53,28 @@ scoped_refptr<base::SingleThreadTaskRunner> GetSSLPlatformKeyTaskRunner() {
   return g_platform_key_task_runner.Get().task_runner();
 }
 
+#ifndef NO_GOSTSSL
+class SSLEmptyPrivateKey : public ThreadedSSLPrivateKey::Delegate {
+ public:
+  SSLEmptyPrivateKey() {}
+  SSLEmptyPrivateKey( const SSLEmptyPrivateKey & ) = delete;
+  SSLEmptyPrivateKey & operator=( const SSLEmptyPrivateKey & ) = delete;
+  ~SSLEmptyPrivateKey() override {}
+
+  std::string GetProviderName() override { return "EmptyPrivateKey"; }
+  std::vector<uint16_t> GetAlgorithmPreferences() override { return {}; }
+  Error Sign(uint16_t algorithm,
+             base::span<const uint8_t> input,
+             std::vector<uint8_t>* signature) override {
+    return ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED;
+  }
+};
+scoped_refptr<SSLPrivateKey> GetEmptyPrivateKey() {
+  return base::MakeRefCounted<ThreadedSSLPrivateKey>(
+      std::make_unique<SSLEmptyPrivateKey>(), GetSSLPlatformKeyTaskRunner());
+}
+#endif // GOSTSSL
+
 bssl::UniquePtr<EVP_PKEY> GetClientCertPublicKey(
     const X509Certificate* certificate) {
   crypto::OpenSSLErrStackTracer tracker(FROM_HERE);
diff --git a/net/ssl/ssl_platform_key_util.h b/net/ssl/ssl_platform_key_util.h
index 0d0793473e626..f4ca1e8408539 100644
--- a/net/ssl/ssl_platform_key_util.h
+++ b/net/ssl/ssl_platform_key_util.h
@@ -15,6 +15,9 @@
 #include "base/memory/scoped_refptr.h"
 #include "base/task/single_thread_task_runner.h"
 #include "net/base/net_export.h"
+#ifndef NO_GOSTSSL
+#include "net/ssl/threaded_ssl_private_key.h"
+#endif // GOSTSSL
 #include "third_party/boringssl/src/include/openssl/base.h"
 
 namespace net {
@@ -28,6 +31,10 @@ class X509Certificate;
 NET_EXPORT_PRIVATE scoped_refptr<base::SingleThreadTaskRunner>
 GetSSLPlatformKeyTaskRunner();
 
+#ifndef NO_GOSTSSL
+NET_EXPORT_PRIVATE scoped_refptr<SSLPrivateKey> GetEmptyPrivateKey();
+#endif // GOSTSSL
+
 // Returns the public key of |certificate| as an |EVP_PKEY| or nullptr on error.
 bssl::UniquePtr<EVP_PKEY> GetClientCertPublicKey(
     const X509Certificate* certificate);
diff --git a/sandbox/policy/features.cc b/sandbox/policy/features.cc
index b2e59a297ddeb..b7c3c7fd06e65 100644
--- a/sandbox/policy/features.cc
+++ b/sandbox/policy/features.cc
@@ -29,7 +29,7 @@ BASE_FEATURE(kNetworkServiceSandbox,
 // disallow any syscalls.
 BASE_FEATURE(kNetworkServiceSyscallFilter,
              "NetworkServiceSyscallFilter",
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT);
 // Enables a fine-grained file path allowlist for the network service.
 // Only has an effect if IsNetworkSandboxEnabled() returns true.
 // If the network service sandbox is enabled and |kNetworkServiceFileAllowlist|
@@ -37,7 +37,7 @@ BASE_FEATURE(kNetworkServiceSyscallFilter,
 // allow everything.
 BASE_FEATURE(kNetworkServiceFileAllowlist,
              "NetworkServiceFileAllowlist",
-             base::FEATURE_ENABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT);
 #endif  // BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
 #endif  // !BUILDFLAG(IS_MAC) && !BUILDFLAG(IS_FUCHSIA)
 
@@ -52,7 +52,7 @@ BASE_FEATURE(kWinSboxDisableExtensionPoints,
 // overridden and disabled by policy.
 BASE_FEATURE(kPrintCompositorLPAC,
              "PrintCompositorLPAC",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+             base::FEATURE_DISABLED_BY_DEFAULT); // DISABLED
 
 // Enables Renderer AppContainer
 BASE_FEATURE(kRendererAppContainer,
diff --git a/sandbox/policy/mac/common.sb b/sandbox/policy/mac/common.sb
index da8e53d47892e..e05d7a4fb2692 100644
--- a/sandbox/policy/mac/common.sb
+++ b/sandbox/policy/mac/common.sb
@@ -194,6 +194,23 @@
   (subpath "/Library/Apple/System/Library/PrivateFrameworks")
 )
 
+(allow file*
+  (subpath "/opt/cprocsp")
+  (subpath "/etc/opt/cprocsp")
+  (subpath "/var/opt/cprocsp")
+  (subpath "/private/etc/opt/cprocsp")
+  (subpath "/private/var/opt/cprocsp")
+  (subpath "/Applications/CryptoPro")
+  (subpath "/Applications/CryptoPro_ECP.app")
+  (subpath "/Library")
+)
+
+(allow mach-lookup
+  (global-name "com.apple.windowserver.active")
+  (global-name "com.apple.UNCUserNotification")
+  (global-name "com.apple.ctkpcscd")
+)
+
 ; Reads from /etc.
 ; This is read by CFPrefs calling getpwuid in a loop. libinfo then fails to
 ; contact any of the opendirectoryd mach services, and falls back to
diff --git a/sandbox/win/src/process_mitigations.cc b/sandbox/win/src/process_mitigations.cc
index 39282ab6be12d..524a4a3e9b12e 100644
--- a/sandbox/win/src/process_mitigations.cc
+++ b/sandbox/win/src/process_mitigations.cc
@@ -231,6 +231,7 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     // Verify caller is not accidentally setting both mutually exclusive
     // policies.
     DCHECK(!(flags & MITIGATION_DYNAMIC_CODE_DISABLE_WITH_OPT_OUT));
+#ifdef NO_GOSTSSL
     PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
     policy.ProhibitDynamicCode = true;
 
@@ -239,6 +240,7 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
       return false;
     }
     applied_flags |= MITIGATION_DYNAMIC_CODE_DISABLE;
+#endif // GOSTSSL
   }
 
   // Enable font policies.
@@ -258,6 +260,7 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
 
   // Enable binary signing policies.
   if (flags & MITIGATION_FORCE_MS_SIGNED_BINS) {
+#ifdef NO_GOSTSSL
     PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy = {};
     // Allow only MS signed binaries.
     policy.MicrosoftSignedOnly = true;
@@ -270,6 +273,7 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
       return false;
     }
     applied_flags |= MITIGATION_FORCE_MS_SIGNED_BINS;
+#endif // GOSTSSL
   }
 
   // Enable image load policies.
diff --git a/services/network/public/mojom/ssl_config.mojom b/services/network/public/mojom/ssl_config.mojom
index 39acd635d195e..57fe8ae32346a 100644
--- a/services/network/public/mojom/ssl_config.mojom
+++ b/services/network/public/mojom/ssl_config.mojom
@@ -38,7 +38,7 @@ struct SSLConfig {
   array<string> client_cert_pooling_policy;
 
   // Controls whether post-quantum key agreement in TLS connections is allowed.
-  bool post_quantum_key_agreement_enabled = true;
+  bool post_quantum_key_agreement_enabled = false;
 
   // If false, disables TLS Encrypted ClientHello (ECH). If true, the feature
   // may be enabled or disabled, depending on feature flags.
diff --git a/third_party/blink/renderer/core/frame/reporting_context.cc b/third_party/blink/renderer/core/frame/reporting_context.cc
index 4a121f1283142..a3d0a29ef67f7 100644
--- a/third_party/blink/renderer/core/frame/reporting_context.cc
+++ b/third_party/blink/renderer/core/frame/reporting_context.cc
@@ -59,7 +59,9 @@ const char ReportingContext::kSupplementName[] = "ReportingContext";
 ReportingContext::ReportingContext(ExecutionContext& context)
     : Supplement<ExecutionContext>(context),
       execution_context_(context),
+#if BUILDFLAG(ENABLE_REPORTING)
       reporting_service_(&context),
+#endif
       receivers_(this, &context) {}
 
 // static
@@ -126,7 +128,9 @@ void ReportingContext::Trace(Visitor* visitor) const {
   visitor->Trace(observers_);
   visitor->Trace(report_buffer_);
   visitor->Trace(execution_context_);
+#if BUILDFLAG(ENABLE_REPORTING)
   visitor->Trace(reporting_service_);
+#endif
   visitor->Trace(receivers_);
   Supplement<ExecutionContext>::Trace(visitor);
 }
@@ -149,6 +153,7 @@ void ReportingContext::CountReport(Report* report) {
   UseCounter::Count(execution_context_, feature);
 }
 
+#if BUILDFLAG(ENABLE_REPORTING)
 const HeapMojoRemote<mojom::blink::ReportingServiceProxy>&
 ReportingContext::GetReportingService() const {
   if (!reporting_service_.is_bound()) {
@@ -158,6 +163,7 @@ ReportingContext::GetReportingService() const {
   }
   return reporting_service_;
 }
+#endif
 
 void ReportingContext::NotifyInternal(Report* report) {
   if (!ShouldReportBeVisibleToObservers(report)) {
@@ -184,6 +190,7 @@ void ReportingContext::NotifyInternal(Report* report) {
 
 void ReportingContext::SendToReportingAPI(Report* report,
                                           const String& endpoint) const {
+#if BUILDFLAG(ENABLE_REPORTING)
   const String& type = report->type();
   if (!(type == ReportType::kCSPViolation || type == ReportType::kCSPHash ||
         type == ReportType::kDeprecation ||
@@ -263,6 +270,7 @@ void ReportingContext::SendToReportingAPI(Report* report,
         url, endpoint, body->featureId(), body->disposition(), body->message(),
         body->sourceFile(), line_number, column_number);
   }
+#endif
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/frame/reporting_context.h b/third_party/blink/renderer/core/frame/reporting_context.h
index 48d64ece3def4..1749703e33cd6 100644
--- a/third_party/blink/renderer/core/frame/reporting_context.h
+++ b/third_party/blink/renderer/core/frame/reporting_context.h
@@ -5,6 +5,7 @@
 #ifndef THIRD_PARTY_BLINK_RENDERER_CORE_FRAME_REPORTING_CONTEXT_H_
 #define THIRD_PARTY_BLINK_RENDERER_CORE_FRAME_REPORTING_CONTEXT_H_
 
+#include "net/net_buildflags.h"
 #include "third_party/blink/public/mojom/frame/reporting_observer.mojom-blink.h"
 #include "third_party/blink/public/mojom/reporting/reporting.mojom-blink.h"
 #include "third_party/blink/renderer/core/core_export.h"
@@ -57,8 +58,10 @@ class CORE_EXPORT ReportingContext : public GarbageCollected<ReportingContext>,
   // Counts the use of a report type via UseCounter.
   void CountReport(Report*);
 
+#if BUILDFLAG(ENABLE_REPORTING)
   const HeapMojoRemote<mojom::blink::ReportingServiceProxy>&
   GetReportingService() const;
+#endif
 
   void NotifyInternal(Report* report);
   // Send |report| via the Reporting API to |endpoint|.
@@ -69,10 +72,12 @@ class CORE_EXPORT ReportingContext : public GarbageCollected<ReportingContext>,
       report_buffer_;
   Member<ExecutionContext> execution_context_;
 
+#if BUILDFLAG(ENABLE_REPORTING)
   // This is declared mutable so that the service endpoint can be cached by
   // const methods.
   mutable HeapMojoRemote<mojom::blink::ReportingServiceProxy>
       reporting_service_;
+#endif
 
   // There might be up to two ReportingObservers stored here: one that is called
   // from the CrossOriginEmbedderPolicyReporter and one that is called from the
diff --git a/third_party/boringssl/BUILD.gn b/third_party/boringssl/BUILD.gn
index b962901a7db8e..11e0a7ec015c2 100644
--- a/third_party/boringssl/BUILD.gn
+++ b/third_party/boringssl/BUILD.gn
@@ -140,6 +140,7 @@ if (is_msan) {
 
 component("boringssl") {
   sources = rebase_path(all_sources, ".", "src")
+  sources += [ "gostssl.cpp", "msspi.cpp" ]
   public = rebase_path(all_headers, ".", "src")
   friend = [ ":*" ]
   deps = [ "//third_party/boringssl/src/third_party/fiat:fiat_license" ]
diff --git a/ui/webui/resources/cr_components/searchbox/searchbox.html b/ui/webui/resources/cr_components/searchbox/searchbox.html
index bcc60a876a373..2e55a6bf3b482 100644
--- a/ui/webui/resources/cr_components/searchbox/searchbox.html
+++ b/ui/webui/resources/cr_components/searchbox/searchbox.html
@@ -1,4 +1,11 @@
 <style include="cr-icons">
+  #voiceSearchButton {
+    visibility: hidden;
+  }
+  #lensSearchButton {
+    visibility: hidden;
+  }
+
   :host {
     /* Embedders should define --cr-searchbox-min-width. */
     --cr-searchbox-width: var(--cr-searchbox-min-width);
-- 

